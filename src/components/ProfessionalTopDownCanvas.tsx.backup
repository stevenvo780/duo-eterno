import React, { useRef, useEffect, useCallback, useState, useMemo } from 'react';
import { useGame } from '../hooks/useGame';
import { useRenderer } from '../hooks/useRenderer';
import { useDayNightCycle } from '../hooks/useDayNightCycle';
import { DayNightClock } from './DayNightClock';
import { assetManager, type Asset } from '../utils/assetManager';
import { AnimatedEntity } from './AnimatedEntity';
import { useAnimationSystem } from '../hooks/useAnimationSystem';
import type { Entity, Zone, MapElement } from '../types';

interface GameObject {
  id: string;
  asset: Asset;
  x: number;
  y: number;
  shadow?: Asset;
  metadata?: {
    rotation?: number;
    flipX?: boolean;
    weathering?: number;
    naturalVariation?: boolean;
  };
}

interface TerrainTile {
  x: number;
  y: number;
  assetId: string;
  type: 'grass' | 'stone' | 'water' | 'path';
  variant: number;
}

interface Props {
  width: number;
  height: number;
  zoom: number;
  panX: number;
  panY: number;
  onEntityClick?: (entity: Entity) => void;
}

const ProfessionalTopDownCanvas: React.FC<Props> = ({
  width,
  height,
  zoom,
  panX,
  panY,
  onEntityClick
}) => {
  const { gameState } = useGame();
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>();
  
  const { shouldRender } = useRenderer();
  const { getSkyColor, getLightIntensity, phase } = useDayNightCycle();
  useAnimationSystem();

  const [assetsLoaded, setAssetsLoaded] = useState(false);
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [gameObjects, setGameObjects] = useState<GameObject[]>([]);
  const [terrainTiles, setTerrainTiles] = useState<TerrainTile[]>([]);

  // Usar zones y mapElements directamente del GameContext
  const zones = useMemo(() => gameState.zones || [], [gameState.zones]);
  const mapElements = useMemo(() => gameState.mapElements || [], [gameState.mapElements]);

  // Cargar assets esenciales
  useEffect(() => {
    const loadAssets = async () => {
      try {
        setLoadingProgress(10);
        console.log('üé® Iniciando carga de assets...');

        // Precargar carpetas esenciales de assets
        await assetManager.preloadEssentialAssetsByFolders([
          'terrain_tiles',
          'structures', 
          'natural_elements',
          'infrastructure',
          'water',
          'environmental_objects',
          'furniture_objects',
          'ui_icons'
        ]);
        setLoadingProgress(60);

        // Precargar assets esenciales
        await assetManager.preloadEssentialAssets();
        setLoadingProgress(80);

        setLoadingProgress(90);

        const stats = assetManager.getStats();
        console.log('‚úÖ Assets cargados:', stats);

        setLoadingProgress(100);
        setAssetsLoaded(true);

        // Assets cargados exitosamente
      } catch (error) {
        console.error('‚ùå Error cargando assets:', error);
      }
    };

    loadAssets();
  }, []);

  // Generar objetos del juego
  const generateGameObjects = useCallback(async () => {
    if (!assetsLoaded || mapElements.length === 0) return;

    const objects: GameObject[] = [];
    let objectId = 0;

    // Precargar assets de muebles
    try {
      await assetManager.loadAssetsByFolderName('furniture_objects');
    } catch {
      console.warn('‚ö†Ô∏è No se pudieron cargar muebles, usando assets b√°sicos');
    }

    mapElements.forEach((element: MapElement) => {
      let asset: Asset | null = null;

      // Seleccionar asset seg√∫n el tipo de elemento
      switch (element.type) {
        case 'food_zone':
          asset = assetManager.getRandomAssetByType('furniture_objects') ||
                  assetManager.getRandomAssetByType('structures');
          break;
        case 'rest_zone':
          asset = assetManager.getRandomAssetByType('furniture_objects') ||
                  assetManager.getRandomAssetByType('structures');
          break;
        case 'play_zone':
        case 'decoration':
          asset = assetManager.getRandomAssetByType('environmental_objects') ||
                  assetManager.getRandomAssetByType('infrastructure');
          break;
        case 'social_zone':
          asset = assetManager.getRandomAssetByType('environmental_objects') ||
                  assetManager.getRandomAssetByType('furniture_objects');
          break;
        case 'obstacle':
          asset = Math.random() > 0.5 
            ? assetManager.getRandomAssetByType('natural_elements')
            : assetManager.getRandomAssetByType('structures');
          break;
        default:
          asset = assetManager.getRandomAssetByType('environmental_objects');
      }

      if (asset) {
        objects.push({
          id: `obj_${objectId++}`,
          asset,
          x: element.position.x,
          y: element.position.y,
          metadata: {
            rotation: Math.random() * 360,
            naturalVariation: Math.random() > 0.7
          }
        });
      }
    });

    setGameObjects(objects);
    console.log(`‚úÖ Generados ${objects.length} objetos del juego`);
  }, [assetsLoaded, mapElements]);

  // Generar terreno de fondo
  const generateTerrain = useCallback(async () => {
    if (!assetsLoaded) return;

    console.log('üå± Generando terreno base...');
    
    const tiles: TerrainTile[] = [];
    const tileSize = 32;
    const tilesX = Math.ceil(width / tileSize);
    const tilesY = Math.ceil(height / tileSize);
    
    // Cargar assets de terreno
    await assetManager.loadAssetsByFolderName('terrain_tiles');
    const grassAssets = assetManager.getAssetsByType('terrain_tiles');
    
    if (grassAssets.length === 0) {
      console.warn('‚ö†Ô∏è No se encontraron assets de terreno');
      return;
    }

    for (let y = 0; y < tilesY; y++) {
      for (let x = 0; x < tilesX; x++) {
        const worldX = x * tileSize;
        const worldY = y * tileSize;
        
        // Usar variaciones de c√©sped
        const grassAsset = grassAssets[Math.floor(Math.random() * grassAssets.length)];
        
        tiles.push({
          x: worldX,
          y: worldY,
          assetId: grassAsset.id,
          type: 'grass',
          variant: Math.floor(Math.random() * 4)
        });
      }
    }
    
    setTerrainTiles(tiles);
    console.log(`‚úÖ Generados ${tiles.length} tiles de terreno`);
  }, [assetsLoaded, width, height]);
          id: `obj_${objectId++}`,
          asset,
          x: element.position.x,
          y: element.position.y,
          metadata: {
            rotation: Math.random() * 360,
            flipX: Math.random() > 0.5,
            weathering: Math.random() * 0.3,
            naturalVariation: true
          }
        });
      }
    });

    setGameObjects(objects);
    console.log(`‚úÖ Generados ${objects.length} objetos del juego`);
  }, [assetsLoaded, mapElements]);

  useEffect(() => {
    generateGameObjects();
  }, [generateGameObjects]);

  // Funci√≥n de renderizado principal
  const renderProfessionalScene = useCallback(
    (ctx: CanvasRenderingContext2D) => {
      if (!assetsLoaded) return;

      ctx.clearRect(0, 0, width, height);
      ctx.save();
      ctx.scale(zoom, zoom);
      ctx.translate(panX, panY);

      // Renderizar fondo simple
      ctx.fillStyle = getSkyColor();
      ctx.fillRect(-panX, -panY, width / zoom, height / zoom);

      // Renderizar zonas como fondos sutiles
      zones.forEach((zone: Zone) => {
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = zone.color;
        ctx.fillRect(zone.bounds.x, zone.bounds.y, zone.bounds.width, zone.bounds.height);
        ctx.globalAlpha = 1.0;

        // Renderizar nombre de la zona
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.font = 'bold 11px system-ui';
        ctx.fillText(zone.name, zone.bounds.x + 8, zone.bounds.y + 18);
      });

      // Renderizar objetos del juego
      gameObjects.forEach((obj: GameObject) => {
        if (obj.asset?.image) {
          ctx.save();

          // Aplicar transformaciones
          ctx.translate(obj.x + obj.asset.size / 2, obj.y + obj.asset.size / 2);
          if (obj.metadata?.rotation) {
            ctx.rotate((obj.metadata.rotation * Math.PI) / 180);
          }
          if (obj.metadata?.flipX) {
            ctx.scale(-1, 1);
          }

          // Dibujar el asset
          ctx.drawImage(
            obj.asset.image,
            -obj.asset.size / 2,
            -obj.asset.size / 2,
            obj.asset.size,
            obj.asset.size
          );

          ctx.restore();
        }
      });

      // Aplicar efectos de iluminaci√≥n
      const lightIntensity = getLightIntensity();
      if (lightIntensity < 1) {
        ctx.globalAlpha = 1 - lightIntensity;
        ctx.fillStyle = phase === 'night' || phase === 'dawn' ? 'rgba(25, 25, 70, 0.6)' : 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(-panX, -panY, width / zoom, height / zoom);
        ctx.globalAlpha = 1;
      }

      ctx.restore();
    },
    [assetsLoaded, gameObjects, zones, width, height, zoom, panX, panY, getSkyColor, getLightIntensity, phase]
  );

  // Loop de animaci√≥n
  useEffect(() => {
    if (!assetsLoaded) return;

    const animate = () => {
      if (shouldRender() && canvasRef.current) {
        const ctx = canvasRef.current.getContext('2d');
        if (ctx) {
          renderProfessionalScene(ctx);
        }
      }
      animationRef.current = requestAnimationFrame(animate);
    };

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [assetsLoaded, shouldRender, renderProfessionalScene]);

  // Handle canvas click para detectar entidades
  const handleCanvasClick = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {
    if (!onEntityClick || !gameState.entities) return;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = (event.clientX - rect.left) / zoom - panX;
    const y = (event.clientY - rect.top) / zoom - panY;

    // Buscar entidad en la posici√≥n clickeada
    const clickedEntity = gameState.entities.find((entity: Entity) => {
      const distance = Math.sqrt(
        Math.pow(x - entity.position.x, 2) + Math.pow(y - entity.position.y, 2)
      );
      return distance < 20; // Radio de detecci√≥n
    });

    if (clickedEntity) {
      onEntityClick(clickedEntity);
    }
  }, [gameState.entities, onEntityClick, zoom, panX, panY]);

  return (
    <div style={{ position: 'relative', width, height }}>
      <canvas
        ref={canvasRef}
        width={width}
        height={height}
        onClick={handleCanvasClick}
        style={{
          cursor: 'pointer',
          imageRendering: 'pixelated'
        }}
      />

      {/* Entidades animadas superpuestas */}
      {assetsLoaded && gameState.entities?.map((entity: Entity) => (
        <div
          key={entity.id}
          style={{
            position: 'absolute',
            left: entity.position.x * zoom + panX - 16,
            top: entity.position.y * zoom + panY - 16,
            transform: 'translate(-50%, -50%)',
            zIndex: 10,
            pointerEvents: 'none'
          }}
        >
          <AnimatedEntity
            entity={entity}
            size={32}
            showMoodIndicator={true}
            showActivityIndicator={true}
            onClick={() => onEntityClick?.(entity)}
          />
        </div>
      ))}

      {/* Indicador de carga */}
      {!assetsLoaded && (
        <div
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            padding: '20px',
            backgroundColor: 'rgba(0,0,0,0.8)',
            color: 'white',
            borderRadius: '8px',
            textAlign: 'center',
            fontFamily: 'system-ui'
          }}
        >
          <div style={{ marginBottom: '10px' }}>Cargando assets...</div>
          <div
            style={{
              width: '200px',
              height: '20px',
              backgroundColor: 'rgba(255,255,255,0.2)',
              borderRadius: '10px',
              overflow: 'hidden'
            }}
          >
            <div
              style={{
                width: `${loadingProgress}%`,
                height: '100%',
                backgroundColor: '#4ade80',
                transition: 'width 0.3s ease'
              }}
            />
          </div>
          <div style={{ marginTop: '5px', fontSize: '12px' }}>{loadingProgress}%</div>
        </div>
      )}

      {/* Stats de debug */}
      {assetsLoaded && (
        <div
          style={{
            position: 'absolute',
            top: 10,
            left: 10,
            padding: '8px',
            backgroundColor: 'rgba(139, 69, 19, 0.9)',
            color: 'white',
            fontSize: '11px',
            fontFamily: 'monospace',
            border: '1px solid #8B4513'
          }}
        >
          üé® Assets: {assetManager.getStats().totalLoaded} | Objetos: {gameObjects.length}
        </div>
      )}

      {/* Reloj de d√≠a y noche */}
      {assetsLoaded && <DayNightClock position="top-right" size="medium" showPhase={true} />}
    </div>
  );
};

export default ProfessionalTopDownCanvas;